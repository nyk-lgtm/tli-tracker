<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TLI Overlay</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/charts.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            background: transparent;
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .overlay-wrapper {
            background: rgb(12, 18, 32);
            border: 1px solid rgba(13, 148, 136, 0.6);
            border-radius: 8px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            width: 100%;
            overflow: hidden;
        }

        .overlay-container {
            display: grid;
            grid-template-columns: 1fr 1px 1fr 1px 0.8fr;
            align-items: center;
            height: 42px;
            padding: 0;
        }

        .stat-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 0 12px;
        }

        .stat-section {
            display: flex;
            align-items: baseline;
            justify-content: center;
            gap: 4px;
            padding: 0 12px;
        }

        .overlay-wrapper.draggable {
            cursor: move;
        }

        .stat {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 500;
            color: #f1f5f9;
            font-feature-settings: 'tnum' on, 'lnum' on;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
            font-weight: 500;
        }

        .stat-value.positive {
            color: #22d3ee;
        }

        .stat-value.negative {
            color: #f87171;
        }

        .divider {
            width: 1px;
            height: 24px;
            background: rgba(42, 52, 65, 0.8);
            justify-self: center;
        }

        .in-map-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #0d9488;
            box-shadow: 0 0 8px rgba(13, 148, 136, 0.6);
            animation: pulse 2s infinite;
        }

        .in-map-dot.inactive {
            background: #4b5563;
            box-shadow: none;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                box-shadow: 0 0 8px rgba(13, 148, 136, 0.6);
            }
            50% {
                opacity: 0.6;
                box-shadow: 0 0 4px rgba(13, 148, 136, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="overlay-wrapper" id="overlay-wrapper">
        <div class="overlay-container" id="overlay-container">
            <!-- Left: indicator + time + map value -->
            <div class="stat-group">
                <div class="in-map-dot" id="map-indicator"></div>
                <div class="stat">
                    <span class="stat-value" id="map-time">-:-</span>
                </div>
                <div class="stat">
                    <span class="stat-value positive" id="map-value">+0</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Center: rate -->
            <div class="stat-section">
                <span class="stat-value" id="rate">0</span>
                <span class="stat-label">/hr</span>
            </div>

            <div class="divider"></div>

            <!-- Right: map count -->
            <div class="stat-section">
                <span class="stat-label">#</span>
                <span class="stat-value" id="map-count">0</span>
            </div>
        </div>

        <!-- Charts Container -->
        <div class="charts-container" id="charts-container">
            <div class="chart-card chart-pulse hidden">
                <div class="chart-title">Value/Map</div>
                <div id="chart-pulse-content"></div>
            </div>
            <div class="chart-card chart-efficiency hidden">
                <div class="chart-title">Efficiency</div>
                <div id="chart-efficiency-content"></div>
            </div>
            <div class="chart-card chart-donut hidden">
                <div class="chart-title">Loot Distribution</div>
                <div id="chart-donut-content"></div>
            </div>
        </div>
    </div>

    <script src="js/shared-utils.js"></script>
    <script src="js/qwebchannel.js"></script>
    <script src="js/qt_bridge.js"></script>
    <script>
        // Chart color palette
        const CHART_COLORS = [
            '#0d9488', '#22d3ee', '#38bdf8', '#818cf8',
            '#a78bfa', '#f472b6', '#fb7185', '#f59e0b', '#64748b'
        ];

        // State
        let state = {
            inMap: false,
            currentMap: null,
            session: null,
            pinned: false,
            showMapValue: true,
            chartPulseEnabled: false,
            chartEfficiencyEnabled: false,
            chartDonutEnabled: false
        };

        // DOM elements
        const els = {
            wrapper: document.getElementById('overlay-wrapper'),
            container: document.getElementById('overlay-container'),
            mapIndicator: document.getElementById('map-indicator'),
            mapTime: document.getElementById('map-time'),
            mapValue: document.getElementById('map-value'),
            rate: document.getElementById('rate'),
            mapCount: document.getElementById('map-count'),
            chartsContainer: document.getElementById('charts-container'),
            chartPulse: document.getElementById('chart-pulse-content'),
            chartEfficiency: document.getElementById('chart-efficiency-content'),
            chartDonut: document.getElementById('chart-donut-content')
        };

        // BroadcastChannel for settings updates
        const settingsChannel = new BroadcastChannel('tli_settings_channel');
        settingsChannel.onmessage = (event) => {
            if (event.data === 'update') {
                console.log('Settings update received via BroadcastChannel');
                loadSettings();
            }
        };

        // Event handler from Python
        window.onPythonEvent = function(eventType, data) {
            if (eventType === 'state') updateState(data);
            if (eventType === 'settings_reset' || eventType === 'settings_update') {
                loadSettings();
            }
        };

        function updateState(data) {
            state.inMap = data.in_map;
            state.currentMap = data.current_map;
            state.session = data.session;
            render();
            renderCharts();
        }

        function render() {
            // Map indicator
            els.mapIndicator.className = state.inMap ? 'in-map-dot' : 'in-map-dot inactive';

            // Map time
            if (state.currentMap) {
                els.mapTime.textContent = TLI.formatTime(state.currentMap.duration);
                els.mapValue.textContent = TLI.formatValue(state.currentMap.value);
                els.mapValue.className = state.currentMap.value >= 0
                    ? 'stat-value positive'
                    : 'stat-value negative';
            } else {
                els.mapTime.textContent = '-:-';
                els.mapValue.textContent = '+0';
                els.mapValue.className = 'stat-value positive';
            }

            // Session stats
            if (state.session) {
                els.rate.textContent = TLI.formatCompact(state.session.value_per_hour);
                els.mapCount.textContent = state.session.map_count;
            } else {
                els.rate.textContent = '0';
                els.mapCount.textContent = '0';
            }

            // Map value visibility
            const mapValueContainer = els.mapValue.closest('.stat');
            if (mapValueContainer) {
                mapValueContainer.style.display = state.showMapValue ? 'flex' : 'none';
            }
        }

        // ============ Chart Rendering ============

        function renderPulseChart(container, maps, currentMap) {
            if (!container) return;

            // Include current map as a live bar if in a map
            const allMaps = [...maps];
            if (currentMap) {
                allMaps.push({ total_value: currentMap.value || 0, isLive: true });
            }

            const recentMaps = allMaps.slice(-15);
            if (recentMaps.length === 0) {
                container.innerHTML = '<div class="pulse-empty">No maps yet</div>';
                return;
            }
            const maxValue = Math.max(...recentMaps.map(m => m.total_value || 0), 1);
            const barsHTML = recentMaps.map((map) => {
                const value = map.total_value || 0;
                const heightPercent = (value / maxValue) * 100;
                const minHeight = value > 0 ? Math.max(heightPercent, 5) : 2;
                const liveClass = map.isLive ? ' pulse-bar-live' : '';
                return `<div class="pulse-bar${liveClass}" style="height: ${minHeight}%" data-value="${TLI.formatCompact(value)}"></div>`;
            }).join('');
            container.innerHTML = `<div class="pulse-chart">${barsHTML}</div>`;
        }

        function renderEfficiencyChart(container, maps, sessionDuration, currentValue) {
            if (!container) return;
            const points = [];
            let cumulativeValue = 0;
            let cumulativeTime = 0;
            for (const map of maps) {
                cumulativeValue += map.total_value || 0;
                cumulativeTime += map.duration_seconds || 0;
                if (cumulativeTime > 0) {
                    const rate = (cumulativeValue / cumulativeTime) * 3600;
                    points.push({ time: cumulativeTime, rate });
                }
            }
            if (sessionDuration > 0 && currentValue > 0) {
                const currentRate = (currentValue / sessionDuration) * 3600;
                points.push({ time: sessionDuration, rate: currentRate, current: true });
            }
            if (points.length < 2) {
                container.innerHTML = '<div class="efficiency-empty">Need more data</div>';
                return;
            }
            const maxRate = Math.max(...points.map(p => p.rate));
            const maxTime = points[points.length - 1].time;
            const width = 200, height = 60, padding = 4;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            const getX = (time) => padding + (time / maxTime) * chartWidth;
            const getY = (rate) => height - padding - (rate / maxRate) * chartHeight;
            const linePath = points.map((p, i) => {
                const x = getX(p.time), y = getY(p.rate);
                return i === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
            }).join(' ');
            const areaPath = linePath + ` L ${getX(maxTime)} ${height - padding} L ${padding} ${height - padding} Z`;
            const currentRate = points[points.length - 1]?.rate || 0;
            container.innerHTML = `
                <div class="efficiency-chart">
                    <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                        <defs>
                            <linearGradient id="efficiency-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stop-color="#14b8a6" stop-opacity="0.4"/>
                                <stop offset="100%" stop-color="#14b8a6" stop-opacity="0"/>
                            </linearGradient>
                        </defs>
                        <path class="efficiency-area" d="${areaPath}"/>
                        <path class="efficiency-line" d="${linePath}"/>
                        <circle class="efficiency-dot" cx="${getX(maxTime)}" cy="${getY(currentRate)}" r="3"/>
                    </svg>
                </div>
            `;
        }

        function renderDonutChart(container, drops) {
            if (!container) return;
            if (!drops || drops.length === 0) {
                container.innerHTML = '<div class="donut-empty">No drops yet</div>';
                return;
            }
            const itemTotals = {};
            for (const drop of drops) {
                const name = drop.item_name || 'Unknown';
                const value = drop.value || 0;
                if (value > 0) itemTotals[name] = (itemTotals[name] || 0) + value;
            }
            const sortedItems = Object.entries(itemTotals).sort((a, b) => b[1] - a[1]);

            // Top 4 items + "Other" for everything else (5 groups max)
            const topItems = sortedItems.slice(0, 4);
            const otherValue = sortedItems.slice(4).reduce((sum, [_, v]) => sum + v, 0);
            if (otherValue > 0) topItems.push(['Other', otherValue]);

            const total = topItems.reduce((sum, [_, v]) => sum + v, 0);
            if (total === 0) {
                container.innerHTML = '<div class="donut-empty">No valued drops</div>';
                return;
            }
            let currentAngle = 0;
            const gradientStops = topItems.map(([name, value], i) => {
                const percent = (value / total) * 100;
                const startAngle = currentAngle;
                currentAngle += percent;
                return `${CHART_COLORS[i]} ${startAngle}% ${currentAngle}%`;
            }).join(', ');
            const legendHTML = topItems.map(([name, value], i) => {
                const percent = ((value / total) * 100).toFixed(0);
                const truncatedName = name.length > 20 ? name.substring(0, 20) + '...' : name;
                return `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${CHART_COLORS[i]}"></div>
                        <span class="legend-name">${truncatedName}</span>
                        <span class="legend-value">${percent}%</span>
                    </div>
                `;
            }).join('');
            container.innerHTML = `
                <div class="donut-chart">
                    <div class="donut-ring" style="background: conic-gradient(${gradientStops})">
                        <div class="donut-center">${TLI.formatCompact(total)}</div>
                    </div>
                    <div class="donut-legend">${legendHTML}</div>
                </div>
            `;
        }

        // Overlay dimensions
        const OVERLAY_WIDTH = 330;
        const STATS_BAR_HEIGHT = 50;
        const CHART_ROW_HEIGHT = 135; // Height per row of charts

        function updateChartsLayout() {
            const pulseEnabled = state.chartPulseEnabled;
            const efficiencyEnabled = state.chartEfficiencyEnabled;
            const donutEnabled = state.chartDonutEnabled;
            const smallChartsCount = (pulseEnabled ? 1 : 0) + (efficiencyEnabled ? 1 : 0);

            els.chartsContainer.classList.remove('charts-1', 'charts-2', 'charts-3', 'charts-small-1', 'charts-small-2', 'charts-donut-only', 'visible');

            const pulseCard = els.chartsContainer.querySelector('.chart-pulse');
            const efficiencyCard = els.chartsContainer.querySelector('.chart-efficiency');
            const donutCard = els.chartsContainer.querySelector('.chart-donut');

            if (pulseCard) pulseCard.classList.toggle('hidden', !pulseEnabled);
            if (efficiencyCard) efficiencyCard.classList.toggle('hidden', !efficiencyEnabled);
            if (donutCard) donutCard.classList.toggle('hidden', !donutEnabled);

            // Calculate layout class and rows
            let rows = 0;
            if (donutEnabled && smallChartsCount === 0) {
                // Only donut: 1 row full width
                els.chartsContainer.classList.add('visible', 'charts-donut-only');
                rows = 1;
            } else if (donutEnabled && smallChartsCount > 0) {
                // Donut + small charts: small charts on row 1, donut on row 2
                els.chartsContainer.classList.add('visible', `charts-small-${smallChartsCount}`);
                rows = 2;
            } else if (smallChartsCount > 0) {
                // Only small charts (no donut): 1 row
                els.chartsContainer.classList.add('visible', `charts-small-${smallChartsCount}`);
                rows = 1;
            }

            // Calculate required height and resize window
            let totalHeight = STATS_BAR_HEIGHT;
            if (rows > 0) {
                totalHeight += rows * CHART_ROW_HEIGHT;
            }

            // Resize overlay window via Python API
            if (typeof api !== 'undefined') {
                api('resize_overlay', OVERLAY_WIDTH, totalHeight);
            }
        }

        function renderCharts() {
            updateChartsLayout();

            const session = state.session;
            const maps = session?.maps || [];
            const drops = session?.drops || [];
            const sessionDuration = session?.duration_total || 0;
            const currentValue = session?.value || 0;
            const currentMap = state.currentMap;

            if (state.chartPulseEnabled) {
                renderPulseChart(els.chartPulse, maps, currentMap);
            }
            if (state.chartEfficiencyEnabled) {
                renderEfficiencyChart(els.chartEfficiency, maps, sessionDuration, currentValue);
            }
            if (state.chartDonutEnabled) {
                renderDonutChart(els.chartDonut, drops);
            }
        }

        function updatePinUI() {
            if (state.pinned) {
                els.wrapper.classList.remove('draggable');
            } else {
                els.wrapper.classList.add('draggable');
            }
        }

        function handleOverlayDrag(e) {
            if (state.pinned) return;
            if (e.button !== 0) return;
            if (typeof api !== 'undefined') {
                api('start_drag');
            }
            e.preventDefault();
        }

        async function loadSettings() {
            if (typeof api !== 'undefined') {
                try {
                    const settings = await api('get_settings');
                    state.pinned = settings.overlay_pinned !== undefined ? settings.overlay_pinned : false;
                    state.showMapValue = settings.show_map_value !== undefined ? settings.show_map_value : true;
                    state.chartPulseEnabled = settings.chart_pulse_enabled || false;
                    state.chartEfficiencyEnabled = settings.chart_efficiency_enabled || false;
                    state.chartDonutEnabled = settings.chart_donut_enabled || false;
                    updatePinUI();
                    render();
                    renderCharts();
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }

        // Event listeners
        els.wrapper.addEventListener('mousedown', handleOverlayDrag);

        // Initialize on load
        waitForApi().then(loadSettings);

        // Timer loop for smooth updates (stats + all charts)
        setInterval(() => {
            if (state.inMap && state.currentMap) {
                state.currentMap.duration += 1;
                els.mapTime.textContent = TLI.formatTime(state.currentMap.duration);
            }
            if (state.session) {
                state.session.duration_total += 1;
                // Re-render all enabled charts every second for live updates
                renderCharts();
            }
        }, 1000);
    </script>
</body>
</html>
